<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PrologObjectConverter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prolobjectlink-jpp</a> &gt; <a href="index.source.html" class="el_package">org.prolobjectlink.db.prolog</a> &gt; <span class="el_source">PrologObjectConverter.java</span></div><h1>PrologObjectConverter.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * prolobjectlink-jpp
 * %%
 * Copyright (C) 2019 Prolobjectlink Project
 * %%
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Prolobjectlink Project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */
package org.prolobjectlink.db.prolog;

import static io.github.prolobjectlink.prolog.PrologTermType.ATOM_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.DOUBLE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.FALSE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.FLOAT_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.INTEGER_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.LIST_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.LONG_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.NIL_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.STRUCTURE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.TRUE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.VARIABLE_TYPE;

import java.lang.reflect.Field;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Currency;
import java.util.Date;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;

import org.prolobjectlink.db.AbstractConverter;
import org.prolobjectlink.db.ObjectConverter;
import org.prolobjectlink.db.util.Assertions;
import org.prolobjectlink.db.util.JavaLists;
import org.prolobjectlink.db.util.JavaMaps;
import org.prolobjectlink.db.util.JavaReflect;
import org.prolobjectlink.db.util.JavaSets;
import org.prolobjectlink.logging.LoggerConstants;
import org.prolobjectlink.logging.LoggerUtils;

import io.github.prolobjectlink.prolog.PrologDouble;
import io.github.prolobjectlink.prolog.PrologFloat;
import io.github.prolobjectlink.prolog.PrologInteger;
import io.github.prolobjectlink.prolog.PrologLong;
import io.github.prolobjectlink.prolog.PrologProvider;
import io.github.prolobjectlink.prolog.PrologStructure;
import io.github.prolobjectlink.prolog.PrologTerm;
import io.github.prolobjectlink.prolog.PrologVariable;
import io.github.prolobjectlink.prolog.UnknownTermError;

public final class PrologObjectConverter extends AbstractConverter&lt;PrologTerm&gt; implements ObjectConverter&lt;PrologTerm&gt; {

	public PrologObjectConverter(PrologProvider provider) {
<span class="nc" id="L92">		super(provider);</span>
<span class="nc" id="L93">	}</span>

	public Class&lt;?&gt; toClass(String prologType) {
<span class="nc bnc" id="L96" title="All 2 branches missed.">		if (prologType.equals(&quot;atom&quot;)) {</span>
<span class="nc" id="L97">			return String.class;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		} else if (prologType.equals(&quot;integer&quot;)) {</span>
<span class="nc" id="L99">			return Integer.class;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">		} else if (prologType.equals(&quot;float&quot;)) {</span>
<span class="nc" id="L101">			return Float.class;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">		} else if (prologType.equals(&quot;long&quot;)) {</span>
<span class="nc" id="L103">			return Long.class;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">		} else if (prologType.equals(&quot;double&quot;)) {</span>
<span class="nc" id="L105">			return Double.class;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">		} else if (prologType.equals(&quot;list&quot;)) {</span>
<span class="nc" id="L107">			return List.class;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">		} else if (prologType.equals(&quot;date&quot;)) {</span>
<span class="nc" id="L109">			return Date.class;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">		} else if (prologType.equals(&quot;map&quot;)) {</span>
<span class="nc" id="L111">			return Map.class;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">		} else if (prologType.equals(&quot;set&quot;)) {</span>
<span class="nc" id="L113">			return Map.class;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">		} else if (prologType.equals(&quot;collection&quot;)) {</span>
<span class="nc" id="L115">			return Map.class;</span>
		}
<span class="nc" id="L117">		Class&lt;?&gt; clazz = null;</span>
		try {
<span class="nc" id="L119">			return Class.forName(prologType);</span>
<span class="nc" id="L120">		} catch (ClassNotFoundException e) {</span>
			// do nothing
		}
<span class="nc" id="L123">		return clazz;</span>
	}

	public Class&lt;?&gt; toClass(PrologTerm prologTerm) {
<span class="nc bnc" id="L127" title="All 11 branches missed.">		switch (prologTerm.getType()) {</span>
		case NIL_TYPE:
<span class="nc" id="L129">			return null;</span>
		case TRUE_TYPE:
<span class="nc" id="L131">			return Boolean.class;</span>
		case FALSE_TYPE:
<span class="nc" id="L133">			return Boolean.class;</span>
		case ATOM_TYPE:
<span class="nc" id="L135">			return String.class;</span>
		case INTEGER_TYPE:
<span class="nc" id="L137">			return Integer.class;</span>
		case FLOAT_TYPE:
<span class="nc" id="L139">			return Float.class;</span>
		case LONG_TYPE:
<span class="nc" id="L141">			return Long.class;</span>
		case DOUBLE_TYPE:
<span class="nc" id="L143">			return Double.class;</span>
		case LIST_TYPE:
<span class="nc" id="L145">			return Object[].class;</span>
		case STRUCTURE_TYPE:
<span class="nc" id="L147">			String className = removeQuotes(prologTerm.getFunctor());</span>
			try {
<span class="nc" id="L149">				return Class.forName(className);</span>
<span class="nc" id="L150">			} catch (ClassNotFoundException e) {</span>
<span class="nc" id="L151">				LoggerUtils.error(getClass(), LoggerConstants.CLASS_NOT_FOUND, e);</span>
			}
<span class="nc" id="L153">			return null;</span>
		default:
<span class="nc" id="L155">			throw new UnknownTermError(prologTerm);</span>
		}
	}

	public Object toObject(PrologTerm prologTerm) {

<span class="nc bnc" id="L161" title="All 2 branches missed.">		if (prologTerm == null) {</span>
<span class="nc" id="L162">			return null;</span>
		}

<span class="nc bnc" id="L165" title="All 12 branches missed.">		switch (prologTerm.getType()) {</span>
		case NIL_TYPE:
<span class="nc" id="L167">			return null;</span>
		case TRUE_TYPE:
<span class="nc" id="L169">			return true;</span>
		case FALSE_TYPE:
<span class="nc" id="L171">			return false;</span>
		case ATOM_TYPE:
<span class="nc" id="L173">			return removeQuotes(prologTerm.getFunctor());</span>
		case INTEGER_TYPE:
<span class="nc" id="L175">			return ((PrologInteger) prologTerm).getIntegerValue();</span>
		case FLOAT_TYPE:
<span class="nc" id="L177">			return ((PrologFloat) prologTerm).getFloatValue();</span>
		case LONG_TYPE:
<span class="nc" id="L179">			return ((PrologLong) prologTerm).getLongValue();</span>
		case DOUBLE_TYPE:
<span class="nc" id="L181">			return ((PrologDouble) prologTerm).getDoubleValue();</span>
		case VARIABLE_TYPE:
<span class="nc" id="L183">			return null;</span>
		case LIST_TYPE:
<span class="nc" id="L185">			return toObjectsArray(prologTerm.getArguments());</span>
		case STRUCTURE_TYPE:

			// getting class from structure
<span class="nc" id="L189">			Class&lt;?&gt; structureClass = toClass(prologTerm);</span>

			//
<span class="nc" id="L192">			Object object = null;</span>

			// getting class from structure
<span class="nc" id="L195">			Class&lt;?&gt; classPtr = structureClass;</span>

			// creating new instance
<span class="nc" id="L198">			object = JavaReflect.newInstance(classPtr);</span>

<span class="nc" id="L200">			Deque&lt;Field&gt; stack = new ArrayDeque&lt;Field&gt;();</span>

<span class="nc bnc" id="L202" title="All 4 branches missed.">			while (classPtr != null &amp;&amp; classPtr != Object.class) {</span>

				// getting declared fields
<span class="nc" id="L205">				Field[] fields = classPtr.getDeclaredFields();</span>

<span class="nc bnc" id="L207" title="All 2 branches missed.">				for (int i = fields.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L208">					Field field = fields[i];</span>

					// check persistence condition
<span class="nc bnc" id="L211" title="All 4 branches missed.">					if (JavaReflect.isPersistent(field) &amp;&amp; !JavaReflect.isStaticAndFinal(field)) {</span>
<span class="nc" id="L212">						stack.push(field);</span>
					}

				}

				// update class pointer for the next super class
<span class="nc" id="L218">				classPtr = classPtr.getSuperclass();</span>
<span class="nc" id="L219">			}</span>

<span class="nc" id="L221">			PrologTerm[] prologArguments = prologTerm.getArguments();</span>

<span class="nc bnc" id="L223" title="All 4 branches missed.">			for (int i = 0; i &lt; prologArguments.length &amp;&amp; !stack.isEmpty(); i++) {</span>

				//
<span class="nc" id="L226">				Field field = stack.pop();</span>

				// recovery data object
<span class="nc" id="L229">				Object value = toObject(prologTerm.getArguments()[i]);</span>

				// write field with argument value
<span class="nc" id="L232">				JavaReflect.writeValue(field, object, value);</span>

			}

			// java.util.date transformations
<span class="nc bnc" id="L237" title="All 2 branches missed.">			if (structureClass == PrologDate.class) {</span>
<span class="nc" id="L238">				return ((PrologDate) object).getJavaUtilDate();</span>
			}

			// java.sql.time transformations
<span class="nc bnc" id="L242" title="All 2 branches missed.">			else if (structureClass == Time.class) {</span>
<span class="nc" id="L243">				return ((PrologTime) object).getJavaSqlTime();</span>
			}

			// java.sql.time transformations
<span class="nc bnc" id="L247" title="All 2 branches missed.">			else if (structureClass == Timestamp.class) {</span>
<span class="nc" id="L248">				return ((PrologTimestamp) object).getJavaSqlTimestamp();</span>
			}

			// java.util.locale transformations
<span class="nc bnc" id="L252" title="All 2 branches missed.">			else if (structureClass == PrologLocale.class) {</span>
<span class="nc" id="L253">				return ((PrologLocale) object).getJavaUtilLocale();</span>
			}

			// java.util.currency transformations
<span class="nc bnc" id="L257" title="All 2 branches missed.">			else if (structureClass == PrologCurrency.class) {</span>
<span class="nc" id="L258">				return ((PrologCurrency) object).getJavaUtilCurrency();</span>
			}

			// java.util.calendar transformations
<span class="nc bnc" id="L262" title="All 2 branches missed.">			else if (structureClass == PrologCalendar.class) {</span>
<span class="nc" id="L263">				return ((PrologCalendar) object).getJavaUtilCalendar();</span>
			}

			// java.util.collections transformations
<span class="nc bnc" id="L267" title="All 2 branches missed.">			else if (structureClass == PrologVector.class) {</span>
<span class="nc" id="L268">				return JavaLists.vector((PrologVector&lt;?&gt;) object);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">			} else if (structureClass == PrologStack.class) {</span>
<span class="nc" id="L270">				return JavaLists.stack((PrologStack&lt;?&gt;) object);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">			} else if (structureClass == PrologArrayList.class) {</span>
<span class="nc" id="L272">				return JavaLists.arrayList((PrologArrayList&lt;?&gt;) object);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">			} else if (structureClass == PrologLinkedList.class) {</span>
<span class="nc" id="L274">				return JavaLists.linkedList((PrologLinkedList&lt;?&gt;) object);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">			} else if (structureClass == PrologPriorityQueue.class) {</span>
<span class="nc" id="L276">				return JavaLists.priorityQueue((PrologPriorityQueue&lt;?&gt;) object);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">			} else if (structureClass == PrologHashMap.class) {</span>
<span class="nc" id="L278">				return JavaMaps.hashMap((PrologHashMap&lt;?, ?&gt;) object);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">			} else if (structureClass == PrologHashSet.class) {</span>
<span class="nc" id="L280">				return JavaSets.hashSet((PrologHashSet&lt;?&gt;) object);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">			} else if (structureClass == PrologTreeMap.class) {</span>
<span class="nc" id="L282">				return JavaMaps.treeMap((PrologTreeMap) object);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">			} else if (structureClass == PrologTreeSet.class) {</span>
<span class="nc" id="L284">				return JavaSets.treeSet((PrologTreeSet) object);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">			} else if (structureClass == PrologLinkedMap.class) {</span>
<span class="nc" id="L286">				return JavaMaps.linkedHashMap((PrologLinkedMap&lt;?, ?&gt;) object);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">			} else if (structureClass == PrologLinkedSet.class) {</span>
<span class="nc" id="L288">				return JavaSets.linkedHashSet((PrologLinkedSet&lt;?&gt;) object);</span>
			}

<span class="nc" id="L291">			return object;</span>

		default:
<span class="nc" id="L294">			throw new UnknownTermError(prologTerm);</span>
		}
	}

	public PrologTerm toTerm(Object object) {

		// null pointer
<span class="nc bnc" id="L301" title="All 2 branches missed.">		if (object == null) {</span>
<span class="nc" id="L302">			return provider.prologNil();</span>
		}

		// class data type
<span class="nc bnc" id="L306" title="All 2 branches missed.">		else if (object instanceof Class) {</span>
<span class="nc" id="L307">			return toStructure((Class&lt;?&gt;) object, null);</span>
		}

		// string data type
<span class="nc bnc" id="L311" title="All 2 branches missed.">		else if (object instanceof String) {</span>
<span class="nc" id="L312">			return provider.newAtom(&quot;&quot; + (String) object + &quot;&quot;);</span>
		}

		// primitives and wrappers data types
<span class="nc bnc" id="L316" title="All 4 branches missed.">		else if (object.getClass() == boolean.class || object instanceof Boolean) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">			return (Boolean) object ? provider.prologTrue() : provider.prologFalse();</span>
<span class="nc bnc" id="L318" title="All 4 branches missed.">		} else if (object.getClass() == int.class || object instanceof Integer) {</span>
<span class="nc" id="L319">			return provider.newInteger((Integer) object);</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">		} else if (object.getClass() == float.class || object instanceof Float) {</span>
<span class="nc" id="L321">			return provider.newFloat((Float) object);</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">		} else if (object.getClass() == long.class || object instanceof Long) {</span>
<span class="nc" id="L323">			return provider.newLong((Long) object);</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">		} else if (object.getClass() == double.class || object instanceof Double) {</span>
<span class="nc" id="L325">			return provider.newDouble((Double) object);</span>
		}

		// object array
<span class="nc bnc" id="L329" title="All 2 branches missed.">		else if (object instanceof Object[]) {</span>
<span class="nc" id="L330">			return provider.newList(toTermsArray((Object[]) object));</span>
		}

		// java.util.date transformations
<span class="nc bnc" id="L334" title="All 2 branches missed.">		else if (object instanceof Date) {</span>
<span class="nc" id="L335">			return toTerm(new PrologDate(((Date) object).getTime()));</span>
		}

		// java.sql.time transformations
<span class="nc bnc" id="L339" title="All 2 branches missed.">		else if (object instanceof Time) {</span>
<span class="nc" id="L340">			return toTerm(new PrologTime(((Time) object).getTime()));</span>
		}

		// java.sql.timestamp transformations
<span class="nc bnc" id="L344" title="All 2 branches missed.">		else if (object instanceof Timestamp) {</span>
<span class="nc" id="L345">			return toTerm(new PrologTime(((Timestamp) object).getTime()));</span>
		}

		// java.util.locale transformations
<span class="nc bnc" id="L349" title="All 2 branches missed.">		else if (object instanceof Locale) {</span>
<span class="nc" id="L350">			Locale locale = (Locale) object;</span>
<span class="nc" id="L351">			String l = locale.getLanguage();</span>
<span class="nc" id="L352">			String c = locale.getCountry();</span>
<span class="nc" id="L353">			String v = locale.getVariant();</span>
<span class="nc" id="L354">			return toTerm(new PrologLocale(l, c, v));</span>
		}

		// java.util.currency transformations
<span class="nc bnc" id="L358" title="All 2 branches missed.">		else if (object instanceof Currency) {</span>
<span class="nc" id="L359">			Currency currency = (Currency) object;</span>
<span class="nc" id="L360">			String c = currency.getCurrencyCode();</span>
<span class="nc" id="L361">			return toTerm(new PrologCurrency(c));</span>
		}

		// java.util.calendar transformations
<span class="nc bnc" id="L365" title="All 2 branches missed.">		else if (object instanceof Calendar) {</span>
<span class="nc" id="L366">			Calendar c = (Calendar) object;</span>
<span class="nc" id="L367">			int minimalDaysInFirstWeek = c.getMinimalDaysInFirstWeek();</span>
<span class="nc" id="L368">			int firstDayOfWeek = c.getFirstDayOfWeek();</span>
<span class="nc" id="L369">			long timeInMillis = c.getTimeInMillis();</span>
<span class="nc" id="L370">			boolean lenient = c.isLenient();</span>
<span class="nc" id="L371">			return toTerm(new PrologCalendar(lenient, timeInMillis, firstDayOfWeek, minimalDaysInFirstWeek));</span>
		}

		// java.util.collections transformations
<span class="nc bnc" id="L375" title="All 2 branches missed.">		else if (object instanceof Vector) {</span>
<span class="nc" id="L376">			Vector&lt;?&gt; l = (Vector&lt;?&gt;) object;</span>
<span class="nc" id="L377">			return toTerm(PrologLists.vector(l));</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">		} else if (object instanceof java.util.Stack) {</span>
<span class="nc" id="L379">			java.util.Stack&lt;?&gt; l = (java.util.Stack&lt;?&gt;) object;</span>
<span class="nc" id="L380">			return toTerm(PrologLists.stack(l));</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">		} else if (object instanceof ArrayList) {</span>
<span class="nc" id="L382">			ArrayList&lt;?&gt; l = (ArrayList&lt;?&gt;) object;</span>
<span class="nc" id="L383">			return toTerm(PrologLists.arrayList(l));</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">		} else if (object instanceof LinkedList) {</span>
<span class="nc" id="L385">			LinkedList&lt;?&gt; l = (LinkedList&lt;?&gt;) object;</span>
<span class="nc" id="L386">			return toTerm(PrologLists.linkedList(l));</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">		} else if (object instanceof PriorityQueue) {</span>
<span class="nc" id="L388">			PriorityQueue&lt;?&gt; l = (PriorityQueue&lt;?&gt;) object;</span>
<span class="nc" id="L389">			return toTerm(PrologLists.priorityQueue(l));</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">		} else if (object instanceof HashMap) {</span>
<span class="nc" id="L391">			HashMap&lt;?, ?&gt; m = (HashMap&lt;?, ?&gt;) object;</span>
<span class="nc" id="L392">			return toTerm(PrologMaps.hashMap(m));</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">		} else if (object instanceof HashSet) {</span>
<span class="nc" id="L394">			HashSet&lt;?&gt; s = (HashSet&lt;?&gt;) object;</span>
<span class="nc" id="L395">			return toTerm(PrologSets.hashSet(s));</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">		} else if (object instanceof TreeMap) {</span>
<span class="nc" id="L397">			TreeMap m = (TreeMap) object;</span>
<span class="nc" id="L398">			return toTerm(PrologMaps.treeMap(m));</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">		} else if (object instanceof TreeSet) {</span>
<span class="nc" id="L400">			TreeSet s = (TreeSet) object;</span>
<span class="nc" id="L401">			return toTerm(PrologSets.treeSet(s));</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">		} else if (object instanceof LinkedHashMap) {</span>
<span class="nc" id="L403">			LinkedHashMap m = (LinkedHashMap&lt;?, ?&gt;) object;</span>
<span class="nc" id="L404">			return toTerm(PrologMaps.linkedMap(m));</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">		} else if (object instanceof LinkedHashSet) {</span>
<span class="nc" id="L406">			LinkedHashSet&lt;?&gt; s = (LinkedHashSet&lt;?&gt;) object;</span>
<span class="nc" id="L407">			return toTerm(PrologSets.linkedSet(s));</span>
		}

		// structure default case
		else {

<span class="nc" id="L413">			return toStructure(object.getClass(), object);</span>
		}

	}

	public PrologTerm toTerm(Object object, Map&lt;String, PrologTerm&gt; solutionsMap) {

		// null pointer
<span class="nc bnc" id="L421" title="All 2 branches missed.">		if (object == null) {</span>
<span class="nc" id="L422">			return provider.prologNil();</span>
		}

		// class data type
<span class="nc bnc" id="L426" title="All 2 branches missed.">		else if (object instanceof Class) {</span>
<span class="nc" id="L427">			return toStructure((Class&lt;?&gt;) object, null);</span>
		}

		// string data type
<span class="nc bnc" id="L431" title="All 2 branches missed.">		else if (object instanceof String) {</span>
<span class="nc" id="L432">			return provider.newAtom(&quot;&quot; + (String) object + &quot;&quot;);</span>
		}

		// primitives and wrappers data types
<span class="nc bnc" id="L436" title="All 4 branches missed.">		else if (object.getClass() == boolean.class || object instanceof Boolean) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">			return (Boolean) object ? provider.prologTrue() : provider.prologFalse();</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">		} else if (object.getClass() == int.class || object instanceof Integer) {</span>
<span class="nc" id="L439">			return provider.newInteger((Integer) object);</span>
<span class="nc bnc" id="L440" title="All 4 branches missed.">		} else if (object.getClass() == float.class || object instanceof Float) {</span>
<span class="nc" id="L441">			return provider.newFloat((Float) object);</span>
<span class="nc bnc" id="L442" title="All 4 branches missed.">		} else if (object.getClass() == long.class || object instanceof Long) {</span>
<span class="nc" id="L443">			return provider.newLong((Long) object);</span>
<span class="nc bnc" id="L444" title="All 4 branches missed.">		} else if (object.getClass() == double.class || object instanceof Double) {</span>
<span class="nc" id="L445">			return provider.newDouble((Double) object);</span>
		}

		//
<span class="nc bnc" id="L449" title="All 2 branches missed.">		else if (object instanceof Object[]) {</span>
<span class="nc" id="L450">			return provider.newList(toTermsArray((Object[]) object));</span>
		} else {

			// retrieve object class
<span class="nc" id="L454">			Class&lt;?&gt; classPtr = object.getClass();</span>

			// check non empty attribute class or non persistent fields
<span class="nc" id="L457">			classPtr = Assertions.persistent(classPtr, &quot;Non persistent &quot; + classPtr);</span>
<span class="nc" id="L458">			classPtr = Assertions.nonStaticFinal(classPtr, &quot;Non persistent &quot; + classPtr);</span>

			// stack for resolve prolog structure arguments order
<span class="nc" id="L461">			Deque&lt;PrologTerm&gt; stack = new ArrayDeque&lt;PrologTerm&gt;();</span>

			// class name to convert in predicate functor
<span class="nc" id="L464">			String className = classPtr.getName();</span>

			// setting quotes to complex class name
<span class="nc" id="L467">			String functor = &quot;'&quot; + className + &quot;'&quot;;</span>

			// loop for resolve inheritance classes
<span class="nc bnc" id="L470" title="All 4 branches missed.">			while (classPtr != null &amp;&amp; classPtr != Object.class) {</span>

				// getting declared fields
<span class="nc" id="L473">				Field[] fields = classPtr.getDeclaredFields();</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">				for (int i = fields.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L476">					Field field = fields[i];</span>

<span class="nc bnc" id="L478" title="All 4 branches missed.">					if (JavaReflect.isPersistent(field) &amp;&amp; !JavaReflect.isStaticAndFinal(field)) {</span>

<span class="nc" id="L480">						String fieldName = field.getName();</span>

<span class="nc" id="L482">						Object argument = JavaReflect.readValue(field, object);</span>

						// variable name = field name first char in upper case
<span class="nc" id="L485">						String variableName = Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">						if (argument == null) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">							if (solutionsMap.containsKey(variableName)) {</span>
<span class="nc" id="L489">								stack.push(solutionsMap.get(variableName));</span>
							} else {
<span class="nc" id="L491">								PrologVariable variableArgument = provider.newVariable(variableName, i);</span>
<span class="nc" id="L492">								stack.push(variableArgument);</span>
<span class="nc" id="L493">							}</span>
						} else {
<span class="nc" id="L495">							PrologTerm prologArgument = toTerm(argument);</span>
<span class="nc" id="L496">							stack.push(prologArgument);</span>
<span class="nc" id="L497">							solutionsMap.put(variableName, prologArgument);</span>
						}

					}

				}

				// update class pointer for the next super class
<span class="nc" id="L505">				classPtr = classPtr.getSuperclass();</span>
<span class="nc" id="L506">			}</span>

<span class="nc" id="L508">			PrologTerm[] prologArguments = new PrologTerm[stack.size()];</span>
<span class="nc bnc" id="L509" title="All 4 branches missed.">			for (int i = 0; i &lt; prologArguments.length || !stack.isEmpty(); i++) {</span>
<span class="nc" id="L510">				prologArguments[i] = stack.pop();</span>
			}

<span class="nc" id="L513">			return provider.newStructure(functor, prologArguments);</span>

		}
	}

	public PrologTerm[] toTermsArray(Object[] objects) {
<span class="nc" id="L519">		PrologTerm[] terms = new PrologTerm[objects.length];</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">		for (int i = 0; i &lt; objects.length; i++) {</span>
<span class="nc" id="L521">			terms[i] = toTerm(objects[i]);</span>
		}
<span class="nc" id="L523">		return terms;</span>
	}

	private PrologStructure toStructure(Class&lt;?&gt; clazz, Object object) {

<span class="nc" id="L528">		Class&lt;?&gt; classPtr = clazz;</span>

		// check non empty attribute class or non persistent fields
<span class="nc" id="L531">		classPtr = Assertions.persistent(classPtr, &quot;Non persistent &quot; + classPtr);</span>
<span class="nc" id="L532">		classPtr = Assertions.nonStaticFinal(classPtr, &quot;Non persistent &quot; + classPtr);</span>

		// stack for resolve prolog structure arguments order
<span class="nc" id="L535">		Deque&lt;PrologTerm&gt; stack = new ArrayDeque&lt;PrologTerm&gt;();</span>

		// class name to convert in predicate functor
<span class="nc" id="L538">		String functor = &quot;'&quot; + classPtr.getName() + &quot;'&quot;;</span>

		// loop for resolve term inheritance classes
<span class="nc bnc" id="L541" title="All 4 branches missed.">		while (classPtr != null &amp;&amp; classPtr != Object.class) {</span>

			// getting declared fields
<span class="nc" id="L544">			Field[] fields = classPtr.getDeclaredFields();</span>

<span class="nc bnc" id="L546" title="All 2 branches missed.">			for (int i = fields.length - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L547">				Field field = fields[i];</span>

				// check persistence condition
<span class="nc bnc" id="L550" title="All 4 branches missed.">				if (JavaReflect.isPersistent(field) &amp;&amp; !JavaReflect.isStaticAndFinal(field)) {</span>

<span class="nc" id="L552">					String fieldName = field.getName();</span>

<span class="nc bnc" id="L554" title="All 2 branches missed.">					if (object != null) {</span>

<span class="nc" id="L556">						Object argument = JavaReflect.readValue(field, object);</span>
<span class="nc" id="L557">						PrologTerm prologArgument = toTerm(argument);</span>
<span class="nc" id="L558">						stack.push(prologArgument);</span>

<span class="nc" id="L560">					} else {</span>

						// variable name = field name first char in upper case
<span class="nc" id="L563">						String varName = Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);</span>

						// pushing the variable name for create predicate
<span class="nc" id="L566">						stack.push(provider.newVariable(varName, i));</span>
					}

				}

			}

			// update class pointer for the next super class
<span class="nc" id="L574">			classPtr = classPtr.getSuperclass();</span>
<span class="nc" id="L575">		}</span>

<span class="nc" id="L577">		PrologTerm[] prologArguments = new PrologTerm[stack.size()];</span>
<span class="nc bnc" id="L578" title="All 4 branches missed.">		for (int i = 0; i &lt; prologArguments.length || !stack.isEmpty(); i++) {</span>
<span class="nc" id="L579">			prologArguments[i] = stack.pop();</span>
		}

<span class="nc" id="L582">		return provider.newStructure(functor, prologArguments);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>