package org.logicware.pdb.ql.jpql;

import org.logicware.pdb.ql.BoolExp;
import org.logicware.pdb.ql.Dekl;
import org.logicware.pdb.ql.DeklList;
import org.logicware.pdb.ql.Exp;
import org.logicware.pdb.ql.ExpList;
import org.logicware.pdb.ql.Ident;
import org.logicware.pdb.ql.Number;
import org.logicware.pdb.ql.ParList;
import org.logicware.pdb.ql.Program;

// definition of tokens, if applicable with token type 
terminal INPUT, FUNCTIONS, OUTPUT, END, ARGUMENTS;
terminal IF, THEN, ELSE, FI;
terminal COMMA, LPAR, RPAR;
terminal EQ, LE, LEQ, MINUS, PLUS, TIMES, DIV, UMINUS;

terminal String ID, NUMBER;

non terminal Program  program;
non terminal ParList  parlist;
non terminal ExpList  explist;
non terminal DeklList dekllist;
non terminal Dekl     dekl;
non terminal Exp      exp;
non terminal BoolExp  boolexp;
non terminal Ident    ident;
non terminal Number   number;


// precedences, left associativity
precedence left EQ, LE, LEQ;
precedence left MINUS, PLUS;
precedence left TIMES, DIV;
precedence left UMINUS;


// here the rules start 
program       ::= INPUT parlist:p FUNCTIONS dekllist:d OUTPUT explist:o
                                        ARGUMENTS explist:a END
                  {: RESULT = new JpqlProgram(p,d,o,a); :}
                ;

parlist       ::= ident:i
                  {: RESULT = new JpqlParList(i); :}
                | parlist:p COMMA ident:i
                  {: RESULT = new JpqlParList(p,i); :}
                ;

dekllist      ::= dekl:d
                  {: RESULT = new JpqlDeklList(d);:}
                | dekllist:l COMMA dekl:d
                  {: RESULT = new JpqlDeklList(l,d); :}
                ;

dekl          ::= ident:i LPAR parlist:p RPAR EQ exp:e
                  {: RESULT = new JpqlDekl(i,p,e); :}
                ;
                
explist       ::= exp:e
                  {: RESULT = new JpqlExpList(e); :}
                | explist:l COMMA exp:e
                  {: RESULT = new JpqlExpList(l,e); :}
                ;

exp           ::= number:n
                  {: RESULT = n; :}
                | ident:i
                  {: RESULT = i; :}
                | ident:i LPAR explist:e RPAR
                  {: RESULT = new JpqlFun(i,e); :}
                | LPAR exp:e RPAR
                  {: RESULT = e; :}
                | MINUS exp:e                
                  {: RESULT = new JpqlUminus(e); :} %prec UMINUS
                | exp:l PLUS exp:r
                  {: RESULT = new JpqlExpInfix(l,'+',r); :}
                | exp:l TIMES exp:r
                  {: RESULT = new JpqlExpInfix(l,'*',r); :}
                | exp:l DIV exp:r
                  {: RESULT = new JpqlExpInfix(l,'/',r); :}
                | exp:l MINUS exp:r
                  {: RESULT = new JpqlExpInfix(l,'-',r); :}
                | IF boolexp:b THEN exp:t ELSE exp:e FI
                  {: RESULT = new JpqlIfThenElse(b,t,e); :}
                ;

boolexp       ::= exp:l EQ exp:r
                  {: RESULT = new JpqlBoolExp(l,'=',r); :}
                | exp:l LE exp:r
                  {: RESULT = new JpqlBoolExp(l,'<',r); :}
                | exp:l LEQ exp:r
                  {: RESULT = new JpqlBoolExp(l,'!',r); :}
                ;

ident         ::= ID:n
                  {: RESULT = new JpqlIdent(n); :}
                ;

number        ::= NUMBER:z
                  {: RESULT = new JpqlNumber(z); :}
                ;
